//
// Copyright 2021 Vulcanize, Inc.
//

import assert from 'assert';
import debug from 'debug';
import { DeepPartial } from 'typeorm';
import JSONbig from 'json-bigint';
import { ethers } from 'ethers';
import { sha256 } from 'multiformats/hashes/sha2';
import { CID } from 'multiformats/cid';
import _ from 'lodash';

import { JsonFragment } from '@ethersproject/abi';
import { BaseProvider } from '@ethersproject/providers';
import * as codec from '@ipld/dag-json';
import { EthClient } from '@vulcanize/ipld-eth-client';
import { StorageLayout } from '@vulcanize/solidity-mapper';
import { EventInterface, Indexer as BaseIndexer, ValueResult, UNKNOWN_EVENT_NAME, ServerConfig, updateStateForElementaryType, updateStateForMappingType } from '@vulcanize/util';

import { Database } from './database';
import { Contract } from './entity/Contract';
import { Event } from './entity/Event';
import { SyncStatus } from './entity/SyncStatus';
import { HookStatus } from './entity/HookStatus';
import { BlockProgress } from './entity/BlockProgress';
import { IPLDBlock } from './entity/IPLDBlock';
import artifacts from './artifacts/{{inputFileName}}.json';
import { createInitialCheckpoint, handleEvent, createStateDiff } from './hooks';

const log = debug('vulcanize:indexer');

{{#each events as | event |}}
const {{capitalize event.name}}_EVENT = '{{event.name}}';
{{/each}}

export type ResultEvent = {
  block: {
    cid: string;
    hash: string;
    number: number;
    timestamp: number;
    parentHash: string;
  };
  tx: {
    hash: string;
    from: string;
    to: string;
    index: number;
  };

  contract: string;

  eventIndex: number;
  event: any;

  proof: string;
};

export type ResultIPLDBlock = {
  block: {
    cid: string;
    hash: string;
    number: number;
    timestamp: number;
    parentHash: string;
  };
  contractAddress: string;
  cid: string;
  kind: string;
  data: string;
};

export class Indexer {
  _db: Database
  _ethClient: EthClient
  _ethProvider: BaseProvider
  _postgraphileClient: EthClient
  _baseIndexer: BaseIndexer
  _serverConfig: ServerConfig

  _abi: JsonFragment[]
  _storageLayout: StorageLayout
  _contract: ethers.utils.Interface

  constructor (serverConfig: ServerConfig, db: Database, ethClient: EthClient, postgraphileClient: EthClient, ethProvider: BaseProvider) {
    assert(db);
    assert(ethClient);

    this._db = db;
    this._ethClient = ethClient;
    this._postgraphileClient = postgraphileClient;
    this._ethProvider = ethProvider;
    this._baseIndexer = new BaseIndexer(this._db, this._ethClient, this._postgraphileClient, this._ethProvider);

    const { abi, storageLayout } = artifacts;

    assert(abi);
    assert(storageLayout);

    this._abi = abi;
    this._storageLayout = storageLayout;

    this._contract = new ethers.utils.Interface(this._abi);
  }

  getResultEvent (event: Event): ResultEvent {
    const block = event.block;
    const eventFields = JSONbig.parse(event.eventInfo);
    const { tx } = JSON.parse(event.extraInfo);

    return {
      block: {
        cid: block.cid,
        hash: block.blockHash,
        number: block.blockNumber,
        timestamp: block.blockTimestamp,
        parentHash: block.parentHash
      },

      tx: {
        hash: event.txHash,
        from: tx.src,
        to: tx.dst,
        index: tx.index
      },

      contract: event.contract,

      eventIndex: event.index,
      event: {
        __typename: `${event.eventName}Event`,
        ...eventFields
      },

      // TODO: Return proof only if requested.
      proof: JSON.parse(event.proof)
    };
  }

  getResultIPLDBlock (ipldBlock: IPLDBlock): ResultIPLDBlock {
    const block = ipldBlock.block;

    return {
      block: {
        cid: block.cid,
        hash: block.blockHash,
        number: block.blockNumber,
        timestamp: block.blockTimestamp,
        parentHash: block.parentHash
      },
      contractAddress: ipldBlock.contractAddress,
      cid: ipldBlock.cid,
      kind: ipldBlock.kind,
      data: ipldBlock.data
    };
  }

  {{#each queries as | query |}}
  async {{query.name}} (blockHash: string, contractAddress: string
    {{~#each query.params}}, {{this.name~}}: {{this.type~}} {{/each}}
    {{~#if query.stateVariableType~}}
    , diff = false): Promise<ValueResult> {
    {{else~}}
    ): Promise<ValueResult> {
    {{/if}}
    const entity = await this._db.{{query.getQueryName}}({ blockHash, contractAddress
    {{~#each query.params}}, {{this.name~}} {{~/each}} });
    if (entity) {
      log('{{query.name}}: db hit.');

      return {
        value: entity.value,
        proof: JSON.parse(entity.proof)
      };
    }

    log('{{query.name}}: db miss, fetching from upstream server');

    const { block: { number } } = await this._ethClient.getBlockByHash(blockHash);
    const blockNumber = ethers.BigNumber.from(number).toNumber();

    {{#if (compare query.mode @root.constants.MODE_ETH_CALL)}}
    const contract = new ethers.Contract(contractAddress, this._abi, this._ethProvider);
    {{#if (compare query.returnType 'bigint')}}
    let value = await contract.{{query.name}}(
    {{~#each query.params}}{{this.name}}, {{/each}}{ blockTag: blockHash });
    value = value.toString();
    value = BigInt(value);
    {{else}}
    const value = await contract.{{query.name}}(
    {{~#each query.params}}{{this.name}}, {{/each}}{ blockTag: blockHash });
    {{/if}}

    const result: ValueResult = { value };
    {{/if}}

    {{~#if (compare query.mode @root.constants.MODE_STORAGE)}}
    const result = await this._baseIndexer.getStorageValue(
      this._storageLayout,
      blockHash,
      contractAddress,
      '{{query.name}}'{{#if query.params.length}},{{/if}}
      {{#each query.params}}
      {{this.name}}{{#unless @last}},{{/unless}}
      {{/each}}
    );
    {{/if}}

    await this._db.{{query.saveQueryName}}({ blockHash, blockNumber, contractAddress
    {{~#each query.params}}, {{this.name~}} {{/each}}, value: result.value, proof: JSONbig.stringify(result.proof) });

    {{#if query.stateVariableType}}
    {{#if (compare query.stateVariableType 'Mapping')}}
    if (diff) {
      const stateUpdate = updateStateForMappingType({}, '{{query.name}}', [
      {{~#each query.params}}
      {{~this.name}}.toString() {{~#unless @last}}, {{/unless~}}
      {{/each~}}
      ], result.value.toString());
      await this.createDiffStaged(contractAddress, blockHash, stateUpdate);
    }

    {{else if (compare query.stateVariableType 'ElementaryTypeName')}}
    if (diff) {
      const stateUpdate = updateStateForElementaryType({}, '{{query.name}}', result.value.toString());
      await this.createDiffStaged(contractAddress, blockHash, stateUpdate);
    }

    {{else}}
    assert(state === 'none', 'Type not supported for default state.');

    {{/if}}
    {{/if}}
    return result;
  }

  {{/each}}
  async processCanonicalBlock (job: any): Promise<void> {
    const { data: { blockHash } } = job;

    // Finalize staged diff blocks if any.
    await this.finalizeDiffStaged(blockHash);

    // Call custom stateDiff hook.
    await createStateDiff(this, blockHash);
  }

  async createDiffStaged (contractAddress: string, blockHash: string, data: any): Promise<void> {
    const block = await this.getBlockProgress(blockHash);
    assert(block);

    // Create a staged diff block.
    const ipldBlock = await this.prepareIPLDBlock(block, contractAddress, data, 'diff_staged');
    await this.saveOrUpdateIPLDBlock(ipldBlock);
  }

  async finalizeDiffStaged (blockHash: string): Promise<void> {
    const block = await this.getBlockProgress(blockHash);
    assert(block);

    // Get all the staged diff blocks for the given blockHash.
    const stagedBlocks = await this._db.getIPLDBlocks({ block, kind: 'diff_staged' });

    // For each staged block, create a diff block.
    for (const stagedBlock of stagedBlocks) {
      const data = codec.decode(Buffer.from(stagedBlock.data));
      await this.createDiff(stagedBlock.contractAddress, stagedBlock.block.blockHash, data);
    }

    // Remove all the staged diff blocks for current blockNumber.
    await this.removeStagedIPLDBlocks(block.blockNumber);
  }

  async createDiff (contractAddress: string, blockHash: string, data: any): Promise<void> {
    const block = await this.getBlockProgress(blockHash);
    assert(block);

    // Fetch the latest checkpoint for the contract.
    const checkpoint = await this.getLastIPLDBlock(contractAddress, 'checkpoint');

    // There should be an initial checkpoint at least.
    assert(checkpoint, 'Initial checkpoint doesn\'t exist');

    // Check if the latest checkpoint is in the same block.
    assert(checkpoint.block.blockHash !== block.blockHash, 'Checkpoint already created for the block hash.');

    const ipldBlock = await this.prepareIPLDBlock(block, contractAddress, data, 'diff');
    await this.saveOrUpdateIPLDBlock(ipldBlock);
  }

  async processCheckpoint (job: any): Promise<void> {
    // Return if checkpointInterval is <= 0.
    const checkpointInterval = this._serverConfig.checkpointInterval;
    if (checkpointInterval <= 0) return;

    const { data: { blockHash, blockNumber } } = job;

    // Get all the contracts.
    const contracts = await this._db.getContracts({});

    // For each contract, merge the diff till now to create a checkpoint.
    for (const contract of contracts) {
      // Check if contract has checkpointing on.
      if (contract.checkpoint) {
        // If a checkpoint doesn't already exist and blockNumber is equal to startingBlock, create an initial checkpoint.
        const checkpointBlock = await this.getLastIPLDBlock(contract.address, 'checkpoint');

        if (!checkpointBlock) {
          if (blockNumber === contract.startingBlock) {
            await createInitialCheckpoint(this, contract.address, blockHash);
          }
        } else {
          await this.createCheckpoint(contract.address, blockHash, undefined, checkpointInterval);
        }
      }
    }
  }

  async createCheckpoint (contractAddress: string, blockHash?: string, data?: any, checkpointInterval?: number): Promise<string | undefined> {
    const syncStatus = await this.getSyncStatus();
    assert(syncStatus);

    // Getting the current block.
    let currentBlock;

    if (blockHash) {
      currentBlock = await this.getBlockProgress(blockHash);
    } else {
      // In case of empty blockHash from checkpoint CLI, get the latest canonical block for the checkpoint.
      currentBlock = await this.getBlockProgress(syncStatus.latestCanonicalBlockHash);
    }

    assert(currentBlock);

    // Data is passed in case of initial checkpoint.
    // Assuming there will be no events for the contract in this block.
    if (data) {
      const ipldBlock = await this.prepareIPLDBlock(currentBlock, contractAddress, data, 'checkpoint');
      await this.saveOrUpdateIPLDBlock(ipldBlock);

      return;
    }

    // If data is not passed, create from previous checkpoint and diffs after that.

    // Make sure the block is marked complete.
    assert(currentBlock.isComplete, 'Block for a checkpoint should be marked as complete');

    // Make sure the block is in the pruned region.
    assert(currentBlock.blockNumber <= syncStatus.latestCanonicalBlockNumber, 'Block for a checkpoint should be in the pruned region');

    // Fetch the latest checkpoint for the contract.
    const checkpointBlock = await this.getLastIPLDBlock(contractAddress, 'checkpoint');
    assert(checkpointBlock);

    // Check (only if checkpointInterval is passed) if it is time for a new checkpoint.
    if (checkpointInterval && checkpointBlock.block.blockNumber > (currentBlock.blockNumber - checkpointInterval)) {
      return;
    }

    const { block: { blockNumber: checkpointBlockNumber } } = checkpointBlock;

    // Fetching all diff blocks after checkpoint.
    const diffBlocks = await this.getPrevIPLDBlocksAfterCheckpoint(contractAddress, checkpointBlockNumber);

    data = codec.decode(Buffer.from(checkpointBlock.data)) as any;

    for (const diffBlock of diffBlocks) {
      const diff = codec.decode(Buffer.from(diffBlock.data));
      data = _.merge(data, diff);
    }

    const ipldBlock = await this.prepareIPLDBlock(currentBlock, contractAddress, data, 'checkpoint');
    await this.saveOrUpdateIPLDBlock(ipldBlock);

    return currentBlock.blockHash;
  }

  async getIPLDBlockByCid (cid: string): Promise<IPLDBlock | undefined> {
    const ipldBlocks = await this._db.getIPLDBlocks({ cid });

    // There can be only one IPLDBlock with a particular cid.
    assert(ipldBlocks.length <= 1);

    return ipldBlocks[0];
  }

  async getLastIPLDBlock (contractAddress: string, kind?: string): Promise<IPLDBlock | undefined> {
    return this._db.getLastIPLDBlock(contractAddress, kind);
  }

  async getPrevIPLDBlock (blockHash: string, contractAddress: string, kind?: string): Promise<IPLDBlock | undefined> {
    const dbTx = await this._db.createTransactionRunner();
    let res;

    try {
      res = await this._db.getPrevIPLDBlock(dbTx, blockHash, contractAddress, kind);
      await dbTx.commitTransaction();
    } catch (error) {
      await dbTx.rollbackTransaction();
      throw error;
    } finally {
      await dbTx.release();
    }
    return res;
  }

  async getPrevIPLDBlocksAfterCheckpoint (contractAddress: string, checkpointBlockNumber: number): Promise<IPLDBlock[]> {
    return this._db.getPrevIPLDBlocksAfterCheckpoint(contractAddress, checkpointBlockNumber);
  }

  async prepareIPLDBlock (block: BlockProgress, contractAddress: string, data: any, kind: string):Promise<any> {
    assert(_.includes(['diff', 'checkpoint', 'diff_staged'], kind));

    // Get an existing 'diff' | 'diff_staged' IPLDBlock for current block, contractAddress.
    let currentIPLDBlocks: IPLDBlock[] = [];
    if (kind !== 'checkpoint') {
      currentIPLDBlocks = await this._db.getIPLDBlocks({ block, contractAddress, kind });
    }

    // There can be only one IPLDBlock for a (block, contractAddress, kind) combination.
    assert(currentIPLDBlocks.length <= 1);
    const currentIPLDBlock = currentIPLDBlocks[0];

    // Update currentIPLDBlock if it exists and is of same kind.
    let ipldBlock;
    if (currentIPLDBlock) {
      ipldBlock = currentIPLDBlock;

      // Update the data field.
      const oldData = codec.decode(Buffer.from(currentIPLDBlock.data));
      data = _.merge(oldData, data);
    } else {
      ipldBlock = new IPLDBlock();

      // Fetch the parent IPLDBlock.
      const parentIPLDBlock = await this.getLastIPLDBlock(contractAddress);

      // Setting the meta-data for an IPLDBlock (done only once per block).
      data.meta = {
        id: contractAddress,
        kind,
        parent: {
          '/': parentIPLDBlock ? parentIPLDBlock.cid : null
        },
        ethBlock: {
          cid: {
            '/': block.cid
          },
          num: block.blockNumber
        }
      };
    }

    // Encoding the data using dag-json codec.
    const bytes = codec.encode(data);

    // Calculating sha256 (multi)hash of the encoded data.
    const hash = await sha256.digest(bytes);

    // Calculating the CID: v1, code: dag-json, hash.
    const cid = CID.create(1, codec.code, hash);

    // Update ipldBlock with new data.
    ipldBlock = Object.assign(ipldBlock, {
      block,
      contractAddress,
      cid: cid.toString(),
      kind: data.meta.kind,
      data: bytes
    });

    return ipldBlock;
  }

  async saveOrUpdateIPLDBlock (ipldBlock: IPLDBlock): Promise<IPLDBlock> {
    return this._db.saveOrUpdateIPLDBlock(ipldBlock);
  }

  async removeStagedIPLDBlocks (blockNumber: number): Promise<void> {
    const dbTx = await this._db.createTransactionRunner();

    try {
      await this._db.removeEntities(dbTx, IPLDBlock, { relations: ['block'], where: { block: { blockNumber }, kind: 'diff_staged' } });
      await dbTx.commitTransaction();
    } catch (error) {
      await dbTx.rollbackTransaction();
      throw error;
    } finally {
      await dbTx.release();
    }
  }

  async triggerIndexingOnEvent (event: Event): Promise<void> {
    const resultEvent = this.getResultEvent(event);

    // Call custom hook function for indexing on event.
    await handleEvent(this, resultEvent);
  }

  async processEvent (event: Event): Promise<void> {
    // Trigger indexing of data based on the event.
    await this.triggerIndexingOnEvent(event);
  }

  parseEventNameAndArgs (kind: string, logObj: any): any {
    let eventName = UNKNOWN_EVENT_NAME;
    let eventInfo = {};

    const { topics, data } = logObj;
    const logDescription = this._contract.parseLog({ data, topics });

    switch (logDescription.name) {
      {{#each events as | event |}}
      case {{capitalize event.name}}_EVENT: {
        eventName = logDescription.name;
        const { {{#each event.params~}} {{this.name}} {{~#unless @last}}, {{/unless}} {{~/each}} } = logDescription.args;
        eventInfo = {
          {{#each event.params}}
          {{#if (compare this.type 'bigint')}}
          {{this.name}}: BigInt(ethers.BigNumber.from({{this.name}}).toString())
          {{~else}}
          {{this.name}}
          {{~/if}}
          {{~#unless @last}},{{/unless}}
          {{/each}}
        };

        break;
      }
      {{/each}}
    }

    return { eventName, eventInfo };
  }

  async watchContract (address: string, kind: string, checkpoint: boolean, startingBlock?: number): Promise<boolean> {
    // Use the checksum address (https://docs.ethers.io/v5/api/utils/address/#utils-getAddress) if input to address is a contract address.
    // If a contract identifier is passed as address instead, no need to convert to checksum address.
    // Customize: use the kind input to filter out non-contract-address input to address.
    const formattedAddress = (kind === '__protocol__') ? address : ethers.utils.getAddress(address);

    if (!startingBlock) {
      const syncStatus = await this.getSyncStatus();
      assert(syncStatus);

      startingBlock = syncStatus.latestIndexedBlockNumber;
    }

    await this._db.saveContract(formattedAddress, kind, checkpoint, startingBlock);

    return true;
  }

  async getHookStatus (): Promise<HookStatus | undefined> {
    const dbTx = await this._db.createTransactionRunner();
    let res;

    try {
      res = await this._db.getHookStatus(dbTx);
      await dbTx.commitTransaction();
    } catch (error) {
      await dbTx.rollbackTransaction();
      throw error;
    } finally {
      await dbTx.release();
    }

    return res;
  }

  async updateHookStatusProcessedBlock (blockNumber: number): Promise<HookStatus> {
    const dbTx = await this._db.createTransactionRunner();
    let res;

    try {
      res = await this._db.updateHookStatusProcessedBlock(dbTx, blockNumber);
      await dbTx.commitTransaction();
    } catch (error) {
      await dbTx.rollbackTransaction();
      throw error;
    } finally {
      await dbTx.release();
    }

    return res;
  }

  async getEventsByFilter (blockHash: string, contract?: string, name?: string): Promise<Array<Event>> {
    return this._baseIndexer.getEventsByFilter(blockHash, contract, name);
  }

  async isWatchedContract (address : string): Promise<Contract | undefined> {
    return this._baseIndexer.isWatchedContract(address);
  }

  async getProcessedBlockCountForRange (fromBlockNumber: number, toBlockNumber: number): Promise<{ expected: number, actual: number }> {
    return this._baseIndexer.getProcessedBlockCountForRange(fromBlockNumber, toBlockNumber);
  }

  async getEventsInRange (fromBlockNumber: number, toBlockNumber: number): Promise<Array<Event>> {
    return this._baseIndexer.getEventsInRange(fromBlockNumber, toBlockNumber);
  }

  async getSyncStatus (): Promise<SyncStatus | undefined> {
    return this._baseIndexer.getSyncStatus();
  }

  async updateSyncStatusIndexedBlock (blockHash: string, blockNumber: number, force = false): Promise<SyncStatus> {
    return this._baseIndexer.updateSyncStatusIndexedBlock(blockHash, blockNumber, force);
  }

  async updateSyncStatusChainHead (blockHash: string, blockNumber: number): Promise<SyncStatus> {
    return this._baseIndexer.updateSyncStatusChainHead(blockHash, blockNumber);
  }

  async updateSyncStatusCanonicalBlock (blockHash: string, blockNumber: number, force = false): Promise<SyncStatus> {
    return this._baseIndexer.updateSyncStatusCanonicalBlock(blockHash, blockNumber, force);
  }

  async getBlocks (blockFilter: { blockNumber?: number, blockHash?: string }): Promise<any> {
    return this._baseIndexer.getBlocks(blockFilter);
  }

  async getEvent (id: string): Promise<Event | undefined> {
    return this._baseIndexer.getEvent(id);
  }

  async getBlockProgress (blockHash: string): Promise<BlockProgress | undefined> {
    return this._baseIndexer.getBlockProgress(blockHash);
  }

  async getBlocksAtHeight (height: number, isPruned: boolean): Promise<BlockProgress[]> {
    return this._baseIndexer.getBlocksAtHeight(height, isPruned);
  }

  async getOrFetchBlockEvents (block: DeepPartial<BlockProgress>): Promise<Array<EventInterface>> {
    return this._baseIndexer.getOrFetchBlockEvents(block, this._fetchAndSaveEvents.bind(this));
  }

  async getBlockEvents (blockHash: string): Promise<Array<Event>> {
    return this._baseIndexer.getBlockEvents(blockHash);
  }

  async removeUnknownEvents (block: BlockProgress): Promise<void> {
    return this._baseIndexer.removeUnknownEvents(Event, block);
  }

  async markBlocksAsPruned (blocks: BlockProgress[]): Promise<void> {
    return this._baseIndexer.markBlocksAsPruned(blocks);
  }

  async updateBlockProgress (blockHash: string, lastProcessedEventIndex: number): Promise<void> {
    return this._baseIndexer.updateBlockProgress(blockHash, lastProcessedEventIndex);
  }

  async getAncestorAtDepth (blockHash: string, depth: number): Promise<string> {
    return this._baseIndexer.getAncestorAtDepth(blockHash, depth);
  }

  async _fetchAndSaveEvents ({ cid: blockCid, blockHash }: DeepPartial<BlockProgress>): Promise<void> {
    assert(blockHash);
    let { block, logs } = await this._ethClient.getLogs({ blockHash });

    const {
      allEthHeaderCids: {
        nodes: [
          {
            ethTransactionCidsByHeaderId: {
              nodes: transactions
            }
          }
        ]
      }
    } = await this._postgraphileClient.getBlockWithTransactions({ blockHash });

    const transactionMap = transactions.reduce((acc: {[key: string]: any}, transaction: {[key: string]: any}) => {
      acc[transaction.txHash] = transaction;
      return acc;
    }, {});

    const dbEvents: Array<DeepPartial<Event>> = [];

    for (let li = 0; li < logs.length; li++) {
      const logObj = logs[li];
      const {
        topics,
        data,
        index: logIndex,
        cid,
        ipldBlock,
        account: {
          address
        },
        transaction: {
          hash: txHash
        },
        receiptCID,
        status
      } = logObj;

      if (status) {
        let eventName = UNKNOWN_EVENT_NAME;
        let eventInfo = {};
        const tx = transactionMap[txHash];
        const extraInfo = { topics, data, tx };

        const contract = ethers.utils.getAddress(address);
        const watchedContract = await this.isWatchedContract(contract);

        if (watchedContract) {
          const eventDetails = this.parseEventNameAndArgs(watchedContract.kind, logObj);
          eventName = eventDetails.eventName;
          eventInfo = eventDetails.eventInfo;
        }

        dbEvents.push({
          index: logIndex,
          txHash,
          contract,
          eventName,
          eventInfo: JSONbig.stringify(eventInfo),
          extraInfo: JSONbig.stringify(extraInfo),
          proof: JSONbig.stringify({
            data: JSONbig.stringify({
              blockHash,
              receiptCID,
              log: {
                cid,
                ipldBlock
              }
            })
          })
        });
      } else {
        log(`Skipping event for receipt ${receiptCID} due to failed transaction.`);
      }
    }

    const dbTx = await this._db.createTransactionRunner();

    try {
      block = {
        cid: blockCid,
        blockHash,
        blockNumber: block.number,
        blockTimestamp: block.timestamp,
        parentHash: block.parent.hash
      };

      await this._db.saveEvents(dbTx, block, dbEvents);
      await dbTx.commitTransaction();
    } catch (error) {
      await dbTx.rollbackTransaction();
      throw error;
    } finally {
      await dbTx.release();
    }
  }
}
